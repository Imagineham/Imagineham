Chapter 1
	C programming language 1969 1973
	Stdlib 1989
	C was made for Unix- practical
	From program to execution- 4 phases - Compilation
		Pre-processor -> READ # files so stdio.h or stdlib.h Results in .i
		Compiler -> translates into assembly Results in .s
		Assembler -> machine-language instructions, .o files are bits read by machines not us
		Linker -> links called functions, printf from printf.o, Results in executable
	
	Optimization! Good programmers know why some functions work better than others
	Buses -> (USB = Universal Serial Bus) used to transfer fixed sized bytes, words
	I/O -> Input/Output like I/O shield for motherboard (connects to external world)
DRAM => Dynamic Random Access Memory, lines of bytes called arrays unique addresses *(pointers). 
Register-> storage device
CPU -> Central Processing Unit (the brain), repeats basic instruction over and over
	Load -> copy into register
	Save -> copy from register
	Update -> copy contents of two registers, ALU adds, copy result in a register
	I/O Read -> Copy from I/O into register
Caches -> temporary memory, used to quicken compilation bc info does not need to travel to *main memory. A Cache using a bus to the CPU is faster, a cache in the CPU is fastest. 

Storage Device Hierarchy
*L0, L1, L2, etc/ Levels. Higher the number, the slower
*list below L0 = Register, increases down
Register
On-chip cache
Off chip cache
Main memory (DRAM)
Local storage
Remote storage (Web servers) 

Operating System (Windows, Linux, Mac)

Practice Prob 2.1
	Dec     Binary         Hex
	0       00000000       00
	55      00110111       37
	136     10001000       88
	243     11110011       F3
	82      01010010       52
	172     10101100       AC
	231     11100111       E7
	167     10100111       A7
	62      00111110       3E
	188     10111100       BC

Practice Prob 2.5
	a        01101001
	b        01010101
	~a       10010110
	~b       10101010
	a & b    01000001
	a | b    01111101
	a ^ b    00111100

Practice Prob 2.9
	x = 0x66 = 01100110
	y = 0x93 = 10010011

	x & y =    00000010 
	x | y =    11110111
	~x | ~y =  11111101
	x & !y =   00000000

	x && y =   00000001
	x || y =   00000001
	!x || !y = 00000000
	x && ~y =  00000001

Practice Prob 2.11	
	x		x << 3	 	[Log]x >> 2		[Arith]x >> 2
	0xF0    10000000	00111100		11111100
			0x80		0x3C			0xFC
	0x0F	01111000	00000011		00000011
			0x7C		0x03			0x03
	0xCC	01100000	00110011		11110011
			0x60		0x33			0xF3
	0x55	10101000	00010101		00010101
			0xA8		0x15			0x15

Practice Prob 2.12
		B2U		B2T
	0	0000	0
	3	0011	3
	8	1000	-8
	A	1010	-6
	F	1111	-1

Practice Prob 2.15

OgHex	TruncHex		OgU		TU 		OgT2		T2 	
0=0000	0=000			0=0000	0=000	0=0000		0=000				
3=0011	3=011			3=0011	3=011	3=0011		3=011				
8=1000	0=000			8=1000	0=000	-8=1000		0=000				
A=1010	2=010			10=1010	2=010	-6=1010		2=010				
F=1111	7=111			15=1111	7=111	-1=1111		-1=111				

Practice Prob 2.17

Hex		Decimal		Decimal		Hex
0=0000	0			0			0
3=0011	3			13			D=1101
8=1000	8			8			8=1000
A=1010	10			6			6=0110
F=1111	15			1			1=0001			

Practice Prob 2.18

x		y		x + y 		x + 4y		Cache
10000	10101	100101
10000	10000	100000
11000	00111	11111
11110	00101	11011
01000	01000	10000


Practice Prob 2.19




Chapter 3
	Assembly

	Pre-processor -> READ # files so stdio.h or stdlib.h Results in .i
	Compiler -> translates into assembly Results in .s
	Assembler -> machine-language instructions, .o files are bits read by machines not us
	Linker -> links called functions, printf from printf.o, Results in executable

	"the assembly programmer's view of the machine differs significantly from that of a C programmer"
		program counter -> (percent)-eip indicated address in memory
		integer register -> 8 locations, stores 32 bits; hold pointers for programs/local variables/etc 
		condition code -> status info, most recent executed arithmetic (ex. if else)
		floating-point -> 8 locations, floats

		machine instructions -> SIMPLE, add numbers, transfer data (ex. movl, subl, shrl...)

	Assembly HW3 Code example (97 in textbook) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	SIMPLE.C ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		int simple (int *xp, int y) {
			int t = *xp + y;
			*xp = t;
			return t;
		}
	|
	|
	|
	v
	SIMPLE.S (COMPILER)	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		.globl simple
		  .type		simple,@function
		simple:
			pushl %ebp				Save frame Pointer		these are the instructions	
			movl %esp, %ebp			Create new pointer		you worked on for homework	
			movl 8 (%ebp), %eax 	Get xp					see page 100. Helpful to 
			movl (%eax), %edx		Retrieve *xp			memorize!!!
			addl 12(%ebp), %edx		Add y to get t		
			movl %edx, %eax			Store t as *xp				
			movl %edp, %esp			Set t as return val					
			movle %edp				reset stack pointer
			popl %edp				Reset frame pointer
			ret						%return
		.Lfel:
		  .size		simple,.Lfel-simple
		  .ident	"GCC: (GNU) 2.95.3 20010315 (release)"

	lines that start with  . direct assembler and Linker


	DATA TYPES
		char 					(1 byte) 					(8 bits)
		char 				8 (string -> 4 bytes) 			(32 bits)
		int 					4 bytes 					(32 bits)
		float 			"single precision" (4 bytes) 		(32 bits)
		double 			"double precision" (8 bytes) 		(64 bits)
		extended-precision 		(10 bytes) 					(80 bits)
		long double 			(12 bytes) 					(96 bits)

	ACCESSING INFORMATION
		SEE PAGE 100 FOR TABLE

			Imediate -> Constant Values -> $-577 $0x1f 
			Register -> %ebp, %esp, %rdi, %rax, etc -> three letters have 32 bits 
			Memory -> memory reference, accesses memory at the effective address

			movb vs vs movw vs movl vs movbl
				movb-> moves a single byte (char, b stands for byte, 8 bit)
				movw-> moves two bytes (w stands for word, 16 bit)
				movl-> moves 4 bytes (l stands for double word, 32 bit)
				movsbl-> from 1 byte to 4, adds 24 leadings 1's 
				movzbl-> from 1 byte to 4, adds 24 leading 0's

			Load Effective Address (leal) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				variant of movl
				function: COPIES EFFECTIVE Address	
					ex: leal 7, assume %edx = x; 
								(%edx, %edx, 4). = 7 + %edx + %edx * 4 = 5x + 7;
					
			sall, shll, sarl, shrl
				sall -> LEFT SHIFT, 0'S
				shll -> LEFT SHIFT, 0'S

				*sarl -> RIGHT SHIFT, ARITHMETIC 
				*shrl -> RIGHT SHIFT, LOGICAL 

	CONTROL

		Condition Codes
			CPU maintains single-bit condition code registers describing the most recent operation

			CF: CARRY FLAG -> most recent operation carried most significant bit-> overflow
			ZF: ZERO FLAG -> most recent operation returned 0
			SF: SIGN FLAG -> most recent operation returned a negative Values
			OF: OVERFLOW FLAG -> most recent operation caused Two's complement overflow, either positive or negative

			ex: say t = a + b

			CF = (unsigned t) < (unsigned a);
			ZF = t == 0;
			SF = t < 0;
			OF = (a < 0 == b < 0) && (t < 0 != a < 0)

			Logical Operators such as xorl, CF and OF are set to 0!!!

	ACCESSING CONDITION CODES 
		"set an integer register" -> sets a single byte to 0 or 1 based on condition Codes
		consider Condition Codes and Implicit Setting a SIDE EFFECT

			sete; For t = a-b, when a = b, t = 0, ZF is set

		SEE FIGURE 3.9 PAGE 112 FOR SET INSTRUCTIONS 
			some example:
				sete D == D <-- ZF (zero flag) == Equal/Zero 
				sets D == D <-- SF (signed flag) == negative
				setns D == D <-- ~SF == Nonnegative 
				setg D == D <-- ~(SF ^ OF) & ~ ZF == Greater than (>)
				setge D == D <-- ~(SF ^ OF) == Greater than or equal to (>=)




		CONDITION CODE EXAMPLE (let a be in %eax, b be in %edx)
			cmpl %eax,%edx			compare a:b
			setl %al				Set low order bytes of %eax to 0 or 1
			movzbl %al,%eax			set remaining bytes of %eax to 0

			Explicit Setting test
				testq Src2, Src1 -> destination is condition code
				testq b, a = a&b without setting destination
				compq Src2, Src1
				compq b, a = a-b without settinng destination 

	Practice Problem 3.7




	CONDITIONAL BRANCHES -> JUMP INSTRUCTIONS	
		jump instruction s== assembly if then else statements
			Usually instructions follow each other in order, however, jump causes the execution	
			to switch to a new order as indicated by a label. 
				labels look like .Li 

			example:
				xorl %eax,%eax				Set %eax to 0
				jmp .Li 					%"goto" .Li
				movl (%eax), %edx			This line is skipped over because jmp
			.Li 
				pop1 %edx

		DIRECT VS INDIRECT JUMPING 
			DIRECT~~~~~~~~
				jmp label -> takes you directly to a label, the label is always encoded as part of
				the instructions
			INDIRECT~~~~~~~~
				jmp *%eax  -> 		the value in register %eax becomes jump target
				jmp *(%eax) -> 		the value in memory becomes the jump target

	Practice Problem 3.8

	CONDITIONAL BRANCHES	
		regular Code in C~~~~~~~~~~~~~~~~~~~
		int absdiff(int x, int y) {
			if (x < y) {
				return y - x; 							%if x < y return y - x to get noneg value
			} else {
				return x - y;							%if x is not < y, return x - y to get nonneg value
			}
		}
		Goto Code in C~~~~~~~~~~~~~~~~~~~~~~
			int gotodiff(int x, int y) {
				int rval;								%define local variable "return value"						

				if (x < y) {							%if x < y, JUMP TO LESS, skip the code right below where
					go to less;							%rval = x -y
				rval = x - y;
				goto done;								%jump to done so you can return rval
				}
				less:									%jmp instruction target  if x < y is true
					rval = y - x;
				done:
					return rval;
			}

		example from lecture:

		val = Test ? Then_Exp : Else_Expr;

		GoTo Version
			ntest = !Test;
			if (ntest) goto Else;				%INVERT NTEST	
			val = Then_Expr;
			goto Done;
		Else:
			val = Else_Expr;
		Done:
			....


	Practice Problem 3.9

	DO-WHILE, WHILE, FOR LOOPS WILL BE DONE ON PAPER. PRACTICE PROBLEM ANSWERS HERE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	Memory Hierarchy 6.1 --> 6.5~~~~~~~~~~~~~~~~~~~~~~~~
		Microarchitetcure
			does not affect software infrastructure

		ISA VS Microarchitecture
			instruction set architecture -> DOES FUNCTION WORK?
				--> programmer visible state, does not change when adding caches
				--> i can see stack, i can see program counter, can see code. 
						%registers, code, memory addresses, assembly, etc ISA
			Microarchitecture ->  PERFORMANCE, HOW DOES FUNCTION WORK
				--> everytime you buy a new processor, microarchitecture is different
						%cache, valid bits, tags, conflict, hits, misses MICRO

		Elements of Program Performance
			Memory Operators x Memory Time
			ALU Ops x ALU Time (bits operations)
		+	Cond Ops x Cond Time
		=		Total Time
		aka "the time of any operation is the time it takes to access instruction memory + the time 
		it takes to perform the operation (which can be another memory access). 

		the time of memory operation is the time it takes to access data memory + instruction memory. 

		CPU-Memory Gap
			DRAM (memory) --> does not improve as fast as CPU, could be about 100 times slower than CPU
			Disk, SSD much slower than DRAM

		MEMORY Hierarchy	
			L0: Registers (x86-64 == 16 regs, each 8 bytes)   			%SMALLEST FASTEST, MOST EXPENSIVE%
			L1: Cache (SRAM, holds lines from L2 cache)
			L2: Cache (SRAM, holds lines from L3 cache)
			L3: Cache (SRAM, holds lines DRAM)
			L4: Main Memory (DRAM, 8, 16, GB of memory, much bigger than registers)
			L5: Local Secondary Storage
			L6: Remote Secondary Storage (internet)						%lARGEST, SLOWEST, CHEAPEST%

			Each Lk serves as a cache for L(k + 1)!!!
		Processor <----> Cache <----> DRAM

			CAPACITY === register << cache << DRAM
			Speed === Register >> cache >> DRAM

			if data is "in fast memory" low latency access
			if data is "not in fast memory long" latency DRAM
				
		Locality *ALL PROGRAMS HAVE LOCALITY*
			(how much locality you have...)
			programs use data and instructions with addresses near or equal to those used recently

			Temporal Locality	
				recently referenced items likely to be referenced again

			Spatial Locality	
				items with nearby addresses tend to be referenced around the same time

			MAKING CLAIMS ABOUT LOCALITY
				understanding how differences in code affect locality
				ex:
					--->for (j = 0; j < N; j++) {
					--->	for (i = 0; i < M; i++) {
							sum += a[i][j]
							}
						}

					VS 

					--->for (i = 0; i < M; i++) {
					--->	for (j = 0; j < N; j++) {
							sum += a[i][j]
							}
						}
					EXAMPLE 2 has better locality because j is the faster changing array dimension in the multi-d
					array ex. The C programming language was made with ROW major order so for continuous accesses 
					in memory. change the rightmost reference always. 

			-->stride-k reference patterns (visiting kth variable) stride-1 ref pattern (continguous) have 
					good spatial localiity
			-->loops have good temporal and spatial locality, SMALLER THE BODY AND GREATER NUMBER OF ITERATIONS THE better

			PRACTICE PROBLEM 6.5
				--->clear1 good temporal locality, good spatial locality. stride-1 ref per struct and row-major ordering 
				--->clear2 good temporal but poor spatial. Each p[i] iterated over once but within each struct hops around.  
				--->clear3 poor spatial and temporal locality. --> goes against row-major ordering, and hops around

			LOCALITY AND MEMORY
				ISA === Processor (Instruction set architecture)
					*processor, cache relationship controlled by compiler
				Microarcitecture === L1, L2, L3 caches + DRAM

		CACHE 
				cache ---> small, fast, expensive 
				DRAM ---> large, slow, cheap 
				
				Data is copied using cache blocks. Cache blocks are 64 bytes in size
				Data is always copied back and forth using transfer units

				"hit" ---> Processor asks for data in block 14, if data is in cache HIT
					  ---> looking for d in k + 1, looks for it in k first. if its in k, HIT

				"miss"---> Processor asks for data in block 12, if data is NOT in cache, MISS
								  IF THERE IS A MISS, MUST MOVE ONTO MEMORY, PUT ONTO CACHE, KICK SOMETHING OUT 
									  THEN PROCESSOR GETS BLOCK 12. 
					  --->


				cache exploiting locality == #hits/#accesess 
				cache failing to exploit locaclity == #misses/#accesses

				Memory to Register mov
					Processor loads request to cache
					check if request is in cache

						IF IT IS -----> hit, return copy of data
						IF IT IS NOT -> miss, read from main memory, replace block in cache with new, return copy

PAGE 306 CACHE DESIGN 	
			S === sets, 2^s (number of bits used, log S) sets. 
			E === blocks; lines per set think of the rectangles 
			B === bytes per cache blocks (usually 64); 2^b bytes per cache block

			valid bit (rly small) mustbe valid for hit
			tag (rly small)

			C (cache size) === S x E x B
			t (tag bits) === number of address bits - (block offset bits + set index bits)
			b (block offset bits) === log_2 B (block size in bytes)
			s (set index bits) === log_2 S (num of sets)

			Types of cache DESIGN
			--->Direct-mapped cache (E === 1)
					because  e is 1, one block per set,
				PRO: each block, there is only one place it can go; SIMPLE
				CON: restrictive, sometimes conflict 	
			--->2-way set associative cache (E === 2)
					there are two blocks per set
					first -> index set
							-> compare tag to both blocks
							-> find tag that matches
							-> if match, take block offset bits etc etc
				PRO: now we have a choice over which block to evict on a miss
				CON: search all blocks per set for tag 
			---> Direct == more cache misses, Simpler
				 fully associative == must search all locations for match, less misses, more complex

			***BLOCKS AND WRITES***
				BLOCK how to replace
					no choice in direct
					associative --> random, least recently used, first in first out! (keep track of oldest block)

				WRITE
					write through --> write to memory, higher traffic simple DESIGN
					write back --> only update copy in cache; DIRTY COPY (different)

			Miss Rate vs Hit Time vs miss Penalty
			miss rate --> misses/accesses OR  1 - hit rate; typical numbers = 3-10 percent L1
			Hit time --> time to deliver a line in cache; typical = 4 clock cycles for L1, 10 clock cycles for L2
			miss penalty --> time required bc of miss; typical 150-500 for main memory

			THE THREE C'S
			COMPULSORY/COLD ---> first reference to block (when there's nothing in cache to match anyways)
									if the cache has been warmed up, compulsor misses won't happen (as much)!
			CAPACITY ---> cache is too small to hold all data needed at a time (the working set)
			CONFLICT ---> misses due to collisions 
							ex: say blocks at level k + 1 must be replaced in block k. block i in k + 1 corresponds to 
									block (i mod 4) at k. so 0, 4, 8, 12 correspond to block 0, 5, 9, 13 block 1 etc tec.
							ex: blocks 0 and 8 go in the same place on the cache but if requested while alternating they 
									will keep missing

						

	CACHE BEHAVIOR
		memory address, 64 bit
			the blocks we have been looking at are interpreted ascii

					tag	|	set index |	off set

				Offset == b bits (B = 2^b bytes per block)
				Set Index == s bits (S = 2^s cache sets; ex: 2 way set, S = 2, so s = 1 (one bit))
				Tag bits (Address size - b - s, usually the left most leftover)

		1) locate set
		2) check tag
		3) if tag matches, and valid is set, HIT, locate data at offset 		
 

	6.1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		RAM --> Random Access Memory
		SRAM --> Static Random Access Memory	
						Inverted pendulum, data can be kept indefinitely with stable left and 
						stable right statuses. FASTEST
		DRAM --> Dynamic Random Access Memory, uses supercells to organize bits. 
					d supercells x w cells (bits) ==> d x w = total info
					supercells organized by rows and columns. r x c == d
		DDR SDRAM --> fastest DRAM

		READS vs WRITES 
			read -> transfers data from main memory TO CPU
			write -> transfers data from CPU TO main memory

			Ex: mov A, %eax
					1) CPU inititaes read. Address of A on system bus (CPU <--> I/O)
					2) system bus transfers to I/o which transfers to memory (SYSTEM <--> I/O <--> MEMORY)
					3) Main memory reads addresson memory bus, fetches data, writes data to bus	
							(MEMORY BUS <--> DRAM)
					4) I/O carries signal from memory bus back to system bus. CPU reads from system 


		DISKS
			Disks store a lot of INFORMATION
PAGE 286 		DISK Capacity = bytes/sector x avg # sectors/track x # tracks/surface x #surfaces/platter x #platter/disk
				Like a record player, disk with magnetic surface, read/write head on arm 

PAGE 295 
	LOCALITY 		

		DIRECT MAPPED CACHE IN ACTION
			--> Let S = 4 ---> s = log_ 2 4 = 2
			--> Let E = 1 ---> direct mapped, one line per set
			--> Let B = 2 ---> b = log_2 2 = 1
			--> Let m = 4 ---> t = m - (b + s) -> t = 1


			Set		Valid 		Tag		block[0]		block[1]
			0		1			0		m[0]			m[1]			%4 bits, 1 byte, from 0 to 1
			1		0									
			2		1			1		m[12]			m[13]	
			3		0										

			1) Address 0, given 0. Compulsory miss
			2) Address 1, given 1. hit. index matches, valid and tag match. 
			3) Address 13, given 13. Compulsory miss. 
			4) Address 8, given 8. Miss, tag doesnt match
			5) Address 0, given 9. Conflict miss, WE JUST TOOK IT OUT AND WE HAD SPACE -_-

		SET ASSOCIATIVE CACHES
			1 < E < C/B
			ex: E = 2 --> 2 way set associative cache
				E = 4 --> 4 way set associative cache

			Each set has E lines of blocks. Functionally the same, cache just searches 
					for line with matching tag 

		Practice Problem 6.9
		
	CALLER VS CALLEE SAVE REGISTERS 
		-->Caller : %eax %edx %ecx
		-->Callee : %ebx %esi % edi


	Arrays 
		-->Remember arrays are contiguous, their size can be determined by L * sizeof (T) bytes


BOMB PROJECT NOTES~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PHASE_1 STRING INPUT 
	-> must have 32 char min
	-> must start with E
	-> second letter must be x, actually must be the same + 1 letter

ANSWER: Exo-biologists have found evidence of amyno acyds cs154

STRINGS_CHECK -> REGISTER USAGE TABLE

REGISTER 				VARIABLE 				INITIALIZED -> UP TO 0x40151B
(64x Callee) %r12 								%r12 = 0x400de0	
(64x Frame) %rbp								%rbp = %rsi => 0x4028d0
(64x Callee) %rbx								%rbx = %rdi => 0x604be0
(64x 1st arg) %rdi			x					%rdi = %rsi =>  0x4028d0 
(64x 2nd arg) %rsi			y					0x4028d0
(32x return) %eax
(32x 3rd arg) %edx
(32x Callee) %r12d
(byte return) %al

STRINGS CHECK- 0x401518

%rdi 0x4028d0 = "Exo-biologists have found evidence of amyno acyds" 
%rax 0x604be0 = "\033[A"

ON FIRST CALL TO STRINGS_LENGTH - 0x40151b 
	(inside strings_length) - 0x401489 - takes in %rdi
	line 0x40148c -> string does not equal 0
		 0x40148e -> rax = 0
		 0x401493 -> "xo-biologists have found evidence of amyno acyds"
		 0x401497 -> rax is now 1. (the same amount string moved)
		 0x40149d -> if not equal to 0, go back and add 1 again
		 0x401493 -> "o-biologists have found evidence of amyno acyds"
		 0x401497 -> rax is now 2. (COUNTS LETTERS IN STRING)
		 ...
		 0x40149f -> %rax = 0x30
		 0x4014a1 -> 



RESULTS OF LINE 40151B
	%rdi = 402901 = "" = string deleted? 
	%rsi = 4028d0
	%rbp = 4028d0
	%r12 = 400de0
	%rax = 0x31 number of letters in the string

Line 401520
	%rdi = 0x604be0 (mov rbx, rdi)
	%r12d = 31 (mov eax %r12d)

LINE 401523 
	%rdi = 0x604be0 "\033[A"

Line 401526 string length
	line ...
		 0x401493 -> "[A"
		 0x401497 -> rax is now 1
		 ...
		 0x401493 -> "A"
		 0x401497 -> rax is now 2
		 ...
		 0x401493 -> ""
		 0x401497 -> rax is now 3

RESULTS OF LINE 401526
	%rdi = 0x604be3 = ""
	%rsi = 4028d0 = "Exo-biologists have found evidence of amyno acyds"
	%rbp = 4028d0 = ^^
	%r12 = 31
	%rax = 0x3 
	%rbx = "\033[A"

Line 40152b 
	%eax = 1

Line 0x401530 -> 0x401533
	if greater than or equal to 0 jump to 0x401591
	cmp %eax, %r12d == r12d - eax == 31 - 4 == 30
	%rdx = 1
	%rax = 4

Line 0x401591
	%rax = 1

Line 0x401593
	%rbx = 0


When input is "I will have a bagel and cream cheese probably soon"

	%rdi = 0x604c13 = ""
	%rax = 0x33
	%r12 = 0x31
	%rbx = 0x604be0 = "I will have a bagel and cream cheese probably soon"
	%rsi = 0x4028d0
	%rbp = 0x4028d0 = ""Exo-biologists have found evidence of amyno acyds"
	%rdx = 0x1


Line 0x401535
	movzbl 0x0(%rbp) == 45 IN BINARYYYYYYY
	%rax = 0x45 = %al

Line 0x40153b
	checks if least sig byte is 0
	test %al %al, failed so we move on

Line 0x40153d
	%al - contents of rbx == 0x000045 - 0x604be0
Line 0x40153f
	is (0x45 - 0x604be0) equal to 0?

Line 0x401541 
	absolute jump

Line 40153f
1: x/i $rdi
	0x604c12 
	2: x/s $rdi  0x604c12 <input_strings+50>:       ""
	3: x/i $rax
	0x45:        
	4: x/s $rax  0x45:     
	5: x/i $r12
	0x31:       
	6: x/i $rbx
	0x604be0 
	7: x/s $rbx  0x604be0 <input_strings>:  "E will have a bagel with cream cheese probably soo"
	8: x/i $rsi
	0x4028d0:    rex.RB js 0x402942
	9: x/s $rsi  0x4028d0:  "Exo-biologists have found evidence of amyno acyds"
	10: x/i $rbp
	0x4028d0:    rex.RB js 0x402942
	11: x/s $rbp  0x4028d0: "Exo-biologists have found evidence of amyno acyds"
	12: x/i $rsp
	0x7fffffffe080:      add    %al,(%rax)
	13: x/i $rdx
	0x1: <error: Cannot access memory at address 0x1>
	14: x/i $al
	0x45:        <error: Cannot access memory at address 0x45>
.


Line 0x401547
	%rbp = 0x4028d1 = "xo-biologists have found evidence of amyno acyds"

Line 0x40154b
	%rbx = 0x604be1 = " will have a bagel with cream cheese probably soo"

Line 0x40154f
	%eax = 0x78

Line 0x401557



BOMB PHASE_2~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~			

%r8 = logists have found evidence of amyno acyds cs154\n

Notes for answer:
	-> must have at least 5 spaces, so 6 values 
	-> first value must be 1
	-> second value must be 2
	-> third value must be 5
	-> fourth value must be 9
	-> fifth value must be 16
	-> sixth value must be 27

ANSWER: 1 2 5 9 16 27

Line 40102a
	%rdi = 0x604c30
	%rbp = 0x4026d0
	%rax = 0x604c30
	%rbx = 0
	%rdx = 0x604c30
	%al = 0x30
	%rsi = 1
	%rsp = 0x7fffffffe088

Line 0x40102b
	%rsp -0x28 == 0x7fffffffe060

Line 0x40102f
	%rax = 0x84c7091b245b8d00
	%fs is a register, can now display.
	%fs == 0x0

Line 0x401038
	0x18 + (rsp) == 0x7fffffffe078

Line 0x40103f
	%rsi = 0x7fffffffe060 == ""
	%rdi = 700700

Line 0x401968
	rsp - 8 = 0x7fffffffe050

Line 0x40196c
	%rdx = 0x7fffffffe060

Line 0x40196f
	%rcx = 0x7fffffffe064: 0 '\000'

Line 0x401973
	%rax = 0x7fffffffe074


	0x401981
	%r8 = 0L`

	0x401985
	%rsi = "%d %d %d %d %d %d"

	0x40198a
	%rax = 0x0

	0x40198f
	%rax = 0x1
	%rdi = "700700"
	%rbx = 0x0
	%rdx = 0x402c17
	%rsi = 0x0
	%rsp = 0x7fffffffe050
	%r8 = 0x6

	0x401994
	%rsp = 0x7fffffffe060

	0x401998
	%rax - 0x5 RAX MUST BE AT LEAST 6 HERE 

	0x4019a2
	%rsp = 0x7fffffffe068
	%rax = 0x6
	%rdi = 0x7fffffffda10 = "6"

	0x401042
		input is "1 2 3 4 5 6" 
		%rsp = 0x7fffffffe070
		%rax = 0x6
		%rdi = 0x7fffffffda10 = "6"
		%rbx = 0x0
		%rdx = 0x7fffffffe084
		%r8 = 0x0
		%r12 = 0x400de0

	0x401047
		4 + rsp must equal 2 or bomb explodes

	0x401053
		%rbx = 0x7fffffffe070 = 1

	0x401056
		%rbp = 0x7fffffffe080 = 5 = rsp + 10

	0x40105b
		%rax = 0x2 = rbx + 4 = 

	0x40105e
		%rax = 0x3 = 2 + (1 == rbx)
	
	0x401060
		%rax = 0x5 = 2 + 3

	...

	0x40106d
		%rbx = 2 - ...74
		%rbp = 4 
		input 1 2 5 3 4 6

	
	
		1       breakpoint     keep y   0x000000000040193c <explode_bomb>
		2       breakpoint     keep y   0x0000000000401029 <phase_2>
		3       breakpoint     keep y   0x0000000000401968 <read_six_numbers>
		4       breakpoint     keep y   0x000000000040198f <read_six_numbers+39>
		6       breakpoint     keep y   0x0000000000401994 <read_six_numbers+44>
		11      breakpoint     keep y   0x0000000000401066 <phase_2+61>

		1:   y  /1bs $rdi
		2:   y  /1bs $rbp
		3:   y  /1bs $rax
		4:   y  /1bs $rbx
		5:   y  /1bs $rdx
		6:   y  /1bs $rsi
		7:   y  /1bs $rsp
		10:   y  /1bi $rdi
		11:   y  /1bi $rbp
		12:   y  /1bi $rax
		13:   y  /1bi $rbx
		14:   y  /1bi $rdx
		15:   y  /1bi $rsi
		16:   y  /1bi $rsp
		18:   y  /1bs $ecx
		19:   y  /1bi $ecx


BOMB PHASE_3~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Notes:
		-> two values 
		-> first value must be LESS THAN OR EQUAL than 7
		-> first value must be LESS THAN OR EQUAL TO 4




	0x401092
		%rdi = 0x604c80 = MY INPUT
		%rbp = 0x426d0
		%rax = 0x604c80 = MY INPUT
		%rdx = 0x604c80 = MY INPUT
		%rsi = 2
		%rsp = 0x7fffffffe090
		%rcx = 0x20
		%rbp = 4204240
		%rbx = 0 
		1: x/s $rdi  0x7fffffffda50:    "5214"
		2: x/s $rbp  0x4026d0 <__libc_csu_init>:        "AWAVA\211\377AUATL\215%.\027 "
		3: x/s $rax  0x0:       <error: Cannot access memory at address 0x0>
		4: x/s $rdx  0x0:       <error: Cannot access memory at address 0x0>
		5: x/s $rsi  0x0:       <error: Cannot access memory at address 0x0>
		6: x/s $rsp  0x7fffffffe0b0:    ""
		7: x/s $rcx  0x20:      <error: Cannot access memory at address 0x20>
		8: /d $rbp = 4204240
		9: /d $rbx = 0
		10: x/s $rbx  0x0:      <error: Cannot access memory at address 0x0>
	

	BOMB PHASE 4

		Notes:
			-> two values
			-> first value must be less than or equal to 14
			-> MUST BE 12





		Rax must equal 43 

		40119e
			%rsp = 0x7fffffffe090 = ""

		4011a2
			%rax = 0x509e823e6470a900
		
		4011ab
			%8 + rsp (98) = 0x509e823e6470a900


		4011b2
			%rcx = 4 + rsp = 94 

		4011b7
			%rdx = 90

			4011ba -> 4011c7
			CHECKS IF TWO INPUTS GIVEN 

	CS 154 OPERATING SYSTEMS

	Exceptions
		-> abrupt change in control flow response to some change in processor state
		-> Application runs , hits exception, OS directs CPU to exception handler, exception runs, 
				returns to next instructions
		
		State vs Event
			state == how the processor is now
			event == CHANGE IN State

		When Exceptions occur, OS directs CPU to exception table which directs CPu to new instruction:
		exception handler. 

		Exception tables:
			Entry 		Exception handler
			0			divvByZero
			1			TimerInterrupt
			2			SegFault 
			3			Etc etc etc ...

		***Exception table entry numbers stored in exception table base register

		EXCEPTION CLASSES
		Class 			Cause 							Async/Sync 			Return

		Interrupt 		Signal from I/O					Async				Always to NEXT instruction
		Trap 			Intentional						Sync				Always to NEXT instruction
		Fault 			Potentially Recoverable Error 	Sync				MIGHT return to current instruction
		Abort			Nonrecoverable					Sync				Never returns
		

		INTERRUPTS	
			-> signals from I/O
			-> hardware interrupts are not caused by instructions
			-> interrupt handlers
			-> always return to next instruction
			-> interrupt pin goes "high" == signal

		TRAPS
			-> Intentional!!! 
			-> also knows as system calls
			-> trap handler
			-> always returns to next instruction
			-> similar to a function call, you cause a trap exception when you want it. 
				--> however, functions run in USER MODE (retricted) traps run in OS MODE (special stack)

		FAULTS
			-> fixable errors!!!
			-> fault handler runs, if handler can correct error return to current instruction
				--> if handler cannot correct error, ABORT 
			-> page fault exception == example
				--> instruction references address not resident in memory must be retrieved
				--> fault handler loads page
				--> problem is fixed and second time instruction is ran, no fault

		ABORTS
			-> kills instruction
			-> passes control to abort handler which returns OS abort routine
			
		
		PROCESSES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			-> an instance of a program in execution
			-> provides the illusion that our program is the only thing CPU + OS are running
			-> programs run in the CONTEXT	of some processor

			Logical Control flow	
				-> Each process has its own logical flow (stepping through instructions)
				-> Processes TAKE TURNS using the processor
				-> each process executes a portion, then temporarily susepended and other processes take their TruncHex
				-> logical control flows are independent. DO NOT AFFECT OTHER PROCESSES
				-> logic flows that overlap in time == concurrent processes
				-> procceses taking turns == MULTITASKING
				-> portion of logic flow == TIME SLICE

			Private Address Spaces	
				-> each program gets its own "private" address space in a process
				-> private address spaces mean one program cannot read or write data from another program

			USER vs KERNEL MODES
				-> applications/programs run in user MODE
				-> ONLY TRANSFERS TO KERNEL WHEN EXCEPTIONS OCCUR 
				-> control passes to exception handler, processor sets mode bit == Kernel mode
				-> handler runs in kernel mode
				-> when handler returns, mode bit is changed. Back to user mode.

				User mode == process not allowed to halt processor, change mode, or initiate I/O operation
							 cannot reference data in kernel address space


		CONTEXTS ~~~~~~~~~~~~~~~~~~~~~~
			-> state the kernel needs to restart
				-> all the data of a program as in registers, program counter, stack, pages, processes, files, etc etc
			-> scheduling == when kernel restarts processes, transfers control to new process using context switches
			-> context switches == save context of current Instruction, restores saved context, passes control 
				--> to new process

		PROCESS ID's (PIDs)~~~~~~~~~~~~~~~~~~~~~~
			-> getpid
			-> getppid == get parent process id
			-> ^^^ return integer of type pid_t defined in a .h files

		PROCESSES~~~~~~~~~~~~
			-> Running == process is executing or waiting to be executed// will be scheduled
			-> Stopped == suspended, will not be scheduled. Stopped until received continue signal
			-> Terminated == process stopped permanently
				--> receiving terminate signal
				--> returning from main
				--> calling exit function sets status to exit status

	FORK~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		-> parents and children
		-> parents and children are identical
		-> Call once, return twice. Both parent and child return for FORK
		-> parent and child run concurrently
		-> separate address spaces, so even if they start with the same variable x they can change and return x differently
		-> shared files, child can use any files parent was using 


		Practice Problem 8.1
			Output of child => x = 2
			Output of Parent => x = 0

		Practice 8.2
			For i - 0, 1, 2 -- 2^3 == 8 lines of hello

		Practice 8.3
			Fork Fork == 4 + 1 = 5

	SIGNALS~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		-> message that notifies a process
		-> signals correspond to system events
		-> signals expose/relate OS exceptions to user processes. exceptions would be invisble without signals
			--> Example: a process that attempts to div by zero, kernel sends SIGFPE to process
		-> Linux has 30 signal types, must check table

		SENDING
			--> kernel sends or delivers a signal by updating the context of destination process
			--> signals are sent when kernel detects system event
			--> process calls kill function, forces kernel to send signal
		RECEIVING 
			--> receiving a signal == process reacting to kernel
			--> process can either ignore, terminate, or "catch"
			--> "catching" a signal == signal handler



OSTEP Chapters 12 - 16

	Virtual Memory
		-> ever address generated by user program is a virtual address
		-> ease of us (OS gives each program large contiguous address psace so programmer doesnt
				have to worry about running out of space for their code)
		-> Isolation & Protection == we don't want 1 program to change data in another 

	Multiprogramming
		-> multiple processes being run at one time
		-> OS would help switch between processes
		-> increased utilization and efficacy

	Time Sharing
		-> logical control flow
		-> processes run with full acess to memory for a while, context is saved, other process ran
		-> as memory grows, process is slower

	Address Spaces	
		-> abstraction of physical memory
		-> holds the code of a process
		-> holds instructions 
		-> stack
		-> holds heap == dynamically-allocated user-managed memory (malloc)


		GOALS OF VIRTUAL MEMORY	
			-> transparency == virtual memory is invisible to running program
				--> virtual memory allows program to behave as if it were using physical memory. illusion
			-> efficiency == virtualization must be as efficicent as possible 
				--> time == programs must not run much slower
				--> space == programs must not use too much space (to account for virtualization)
				--> HARDWARE helps with this. TLB's 
			-> protection == processes are separate. they cannot load store or fetch data from other processes
				--> must not access anything outside its address space
				--> isolation == safe from other faulty or bad processes
				--> processes should be able to fail without breaking others

				all addresses we see as programmers are virtual!!! OS only knows where my code/stack/heap actually is
		

		Types of Memory	
			-> Stack 
				--> allocations/ deallocations happen implicitly
				--> also called automatic memory
				--> ex: declaring variables == stack memory
				--> however, there are bounds. If variable declared inside function. Compiler deallocated memory 
						outside function. (Global vs local variables)
			-> Heap 
				--> long lived memory
				--> all allocations and deallocations are handled by programmer. Compiler does not!
				--> We must allocate we must free 
				--> Ex: int *x = (int *)malloc(sizeof (int));
						int *x == compilers
						(int *) == CAST	type for malloc (malloc always returns void)
						sizeof(int)== size of int in bytes (so 4)

			-> malloc
				--> give it a size, either allocated space on heap or fails and returns NULL
				--> stdlib.h required
				--> malloc takes in 1 input. Number of bytes for size
				--> "sizeof" takes place at compile time not run time. Therefore NOT a function but 
						operator (like &, !, ~, etc)
				--> when mallocing strings (malloc strlen(your-string) + 1).
						the 1 makes space for end of string character (null terminator)
			-> free (opposite of malloc?)
				--> free DEALLOCATES memory
				--> free takes in a pointer allocated by memory
				--> always remember to free! un-free'd allocated memory causes a memory leak!! 
				--> memory leak == can lead to running out of memory 
			
			-> Segmentation Faults 
				--> YOU DID SOMETHING WRONG WITH MEMORY YOU FOOLISH PROGRAMMER AND I AM ANGRY 
			
			-> buffer overflow
				--> malloced almost enough memory (ex. forgetting the + 1 for strings)

Address Translation

	limited direct execution (LDE) 
		-> OS jumps in after x amount of time to check up on programs
		-> OS stays out of the way for efficiency!
		-> OS jumps in to make sure stuff is goin right for control! 

	Address Translation
		-> hardware transforms every memory access into a physical address
		-> every virtual memory address truns into physical address
		-> hardware must work together with OS to manage memory
			--> keeping track of free memory
			--> track used memory
			--> 









